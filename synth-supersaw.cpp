
/*
	FM. BISON hybrid FM synthesis -- Self-contained JP-8000 style supersaw oscillator.
	(C) njdewit technologies (visualizers.nl) & bipolaraudio.nl
	MIT license applies, please see https://en.wikipedia.org/wiki/MIT_License or LICENSE in the project root!
*/

#include "synth-supersaw.h"

namespace SFM
{
	// Keep this a fraction of a feasible Intel level 1 cache size (at least 64KB these days)
	// For true JP-8000 simulation 128 does the trick, but a little extra precision won't hurt
	constexpr unsigned kDetuneSteps = 1024;

	alignas(16) static float s_detuneTab[kDetuneSteps];

	/* static */ void Supersaw::CalculateDetuneTable()
	{
		for (unsigned iStep = 0; iStep < kDetuneSteps; ++iStep)
		{
			constexpr float delta = 1.f/kDetuneSteps;
			const float detune = (float) SampleDetuneCurve(delta*iStep); // Cast to single precision makes no audible difference, so far
			s_detuneTab[iStep] = detune;
		}
	}

	/* static */ double Supersaw::SampleDetuneCurve(double detune)
	{
		SFM_ASSERT_NORM(detune);

		// "Since the Roland JP-8000 is a hardware synthesizer, it uses MIDI protocol to transfer control data.
		//  MIDI values are from a scale of 0 to 127 (128 in total). The detune of the Super Saw is therefore
		//  divided into 128 steps. If the detune is sampled at every 8th interval, it will result in a total of 17
		//  (value 0 also included) data points."
		//
		// Polynomial generated by Adam Szabo using Matlab

		return 
			(10028.7312891634*pow(detune, 11.0)) - (50818.8652045924*pow(detune, 10.0)) + (111363.4808729368*pow(detune, 9.0)) -
			(138150.6761080548*pow(detune, 8.0)) + (106649.6679158292*pow(detune, 7.0)) - (53046.9642751875*pow(detune, 6.0))  + 
			(17019.9518580080*pow(detune, 5.0))  - (3425.0836591318*pow(detune, 4.0))   + (404.2703938388*pow(detune, 3.0))    - 
			(24.1878824391*pow(detune, 2.0))     + (0.6717417634*detune)                + 0.0030115596;		
	}

	/* static */ float Supersaw::SampleDetuneTable(float detune)
	{
		SFM_ASSERT_NORM(detune);

		const unsigned indexA = unsigned(floorf(detune * (kDetuneSteps - 1)));
		const unsigned indexB = indexA + 1;
		const float valA = s_detuneTab[indexA];
		const float valB = s_detuneTab[indexB];
		return lerpf<float>(valA, valB, fracf(detune));
	}

	void Supersaw::Initialize(float frequency, unsigned sampleRate, float detune, float mix)
	{
		m_sampleRate = sampleRate;

		// Reset filter
		m_HPF.reset();

		// Reset DC blocker
		m_blocker.Reset();

		// Set frequency (JP-8000 controls, pitch, filter)
		m_frequency = 0.f; 
		SetFrequency(frequency, detune, mix);
	}
}
